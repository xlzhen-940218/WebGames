<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>完美版移动端俄罗斯方块</title>
    <style>
        /* --- 全局样式 --- */
        :root {
            --bg-color: #121212;
            --game-bg: #000000;
            --panel-bg: #1F1F1F;
            --accent: #BB86FC;
            --text-main: #E0E0E0;
            --btn-color: #2C2C2C;
            --btn-active: #3700B3;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none; /* 禁止浏览器默认滑动行为 */
        }

        /* --- 顶部数据栏 --- */
        #header {
            display: flex;
            justify-content: space-between;
            width: 90%;
            max-width: 400px;
            margin: 10px 0;
            padding: 10px;
            background: var(--panel-bg);
            border-radius: 8px;
            box-sizing: border-box;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }

        .stat-item {
            text-align: center;
        }
        .stat-label { font-size: 10px; color: #888; letter-spacing: 1px; }
        .stat-value { font-size: 18px; font-weight: bold; color: var(--accent); }

        /* --- 游戏主区域 --- */
        #game-container {
            position: relative;
            /* 核心修正：使用 aspect-ratio 锁定宽高比，防止变形 */
            width: auto;
            height: 60vh; /* 占据屏幕高度的 60% */
            aspect-ratio: 10 / 20; 
            border: 2px solid #333;
            background-color: var(--game-bg);
            border-radius: 4px;
            box-shadow: 0 0 15px rgba(187, 134, 252, 0.1);
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* --- 虚拟手柄区域 --- */
        #controls {
            flex: 1; /* 占据剩余空间 */
            width: 100%;
            max-width: 360px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding-bottom: 20px;
            gap: 15px;
        }

        /* 功能键行 (旋转/速降) */
        .func-btns {
            display: flex;
            justify-content: space-around;
            padding: 0 10px;
        }

        /* 方向键行 */
        .dir-btns {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            padding: 0 20px;
            justify-items: center;
        }

        /* 按钮样式 */
        button {
            background-color: var(--btn-color);
            border: none;
            color: white;
            border-radius: 12px;
            font-size: 20px;
            box-shadow: 0 4px 0 #111;
            transition: transform 0.05s, box-shadow 0.05s;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        button:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #111;
            background-color: var(--btn-active);
        }

        .btn-round { width: 65px; height: 65px; border-radius: 50%; }
        .btn-pill { width: 100px; height: 60px; font-size: 16px; font-weight: bold; }
        .btn-drop { background-color: #CF6679; } /* 速降按钮红色 */

        /* --- 游戏结束遮罩 --- */
        #game-over-modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        #game-over-modal h2 { color: #CF6679; margin-bottom: 10px; }
        #restart-btn {
            margin-top: 20px;
            padding: 10px 30px;
            background: var(--accent);
            color: #000;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="header">
        <div class="stat-item">
            <div class="stat-label">SCORE</div>
            <div class="stat-value" id="score">0</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">LEVEL</div>
            <div class="stat-value" id="level">1</div>
        </div>
    </div>

    <div id="game-container">
        <canvas id="tetris" width="300" height="600"></canvas>
        
        <div id="game-over-modal">
            <h2>GAME OVER</h2>
            <p>Score: <span id="final-score">0</span></p>
            <button id="restart-btn" onclick="resetGame()">Try Again</button>
        </div>
    </div>

    <div id="controls">
        <div class="func-btns">
            <button class="btn-pill" id="btn-rotate">↻ 旋转</button>
            <button class="btn-pill btn-drop" id="btn-hard-drop">⚡ 速降</button>
        </div>
        <div class="dir-btns">
            <button class="btn-round" id="btn-left">←</button>
            <button class="btn-round" id="btn-down">↓</button>
            <button class="btn-round" id="btn-right">→</button>
        </div>
    </div>

<script>
    const canvas = document.getElementById('tetris');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const modal = document.getElementById('game-over-modal');
    const finalScoreEl = document.getElementById('final-score');

    // --- 核心常量 (修正版) ---
    const ROW = 20;
    const COL = 10;
    const SQ = 30; // 30px * 20行 = 600px (正好填满 Canvas)
    const VACANT = "#000000"; // 空白颜色

    // 定义方块形状
    const PIECES = [
        [Z, "#FF5252"], [S, "#69F0AE"], [T, "#448AFF"], 
        [O, "#FFD740"], [L, "#FFAB40"], [I, "#40C4FF"], [J, "#E040FB"]
    ];

    function Z(){ return [[[1,1,0],[0,1,1],[0,0,0]], [[0,0,1],[0,1,1],[0,1,0]], [[0,0,0],[1,1,0],[0,1,1]], [[0,1,0],[1,1,0],[1,0,0]]];}
    function S(){ return [[[0,1,1],[1,1,0],[0,0,0]], [[0,1,0],[0,1,1],[0,0,1]], [[0,0,0],[0,1,1],[1,1,0]], [[1,0,0],[1,1,0],[0,1,0]]];}
    function T(){ return [[[0,1,0],[1,1,1],[0,0,0]], [[0,1,0],[0,1,1],[0,1,0]], [[0,0,0],[1,1,1],[0,1,0]], [[0,1,0],[1,1,0],[0,1,0]]];}
    function O(){ return [[[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0]], [[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0]], [[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0]], [[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0]]];}
    function L(){ return [[[0,0,1],[1,1,1],[0,0,0]], [[0,1,0],[0,1,0],[0,1,1]], [[0,0,0],[1,1,1],[1,0,0]], [[1,1,0],[0,1,0],[0,1,0]]];}
    function I(){ return [[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], [[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]], [[0,0,0,0],[0,0,0,0],[1,1,1,1],[0,0,0,0]], [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]]];}
    function J(){ return [[[1,0,0],[1,1,1],[0,0,0]], [[0,1,1],[0,1,0],[0,1,0]], [[0,0,0],[1,1,1],[0,0,1]], [[0,1,0],[0,1,0],[1,1,0]]];}

    let board = [];
    let score = 0;
    let level = 1;
    let gameOver = false;
    let dropStart = Date.now();
    let p; 

    // 初始化网格
    function initBoard() {
        for(let r = 0; r < ROW; r++){
            board[r] = [];
            for(let c = 0; c < COL; c++){
                board[r][c] = VACANT;
            }
        }
    }

    // 绘制单个方格
    function drawSquare(x, y, color){
        ctx.fillStyle = color;
        ctx.fillRect(x*SQ, y*SQ, SQ, SQ);

        if(color !== VACANT){
            // 亮边框
            ctx.strokeStyle = "rgba(255,255,255,0.5)";
            ctx.lineWidth = 2;
            ctx.strokeRect(x*SQ, y*SQ, SQ, SQ);
            
            // 简单的内发光效果
            ctx.fillStyle = "rgba(255,255,255,0.1)";
            ctx.fillRect(x*SQ+5, y*SQ+5, SQ-10, SQ-10);
        } else {
            // 网格线
            ctx.strokeStyle = "#222";
            ctx.lineWidth = 1;
            ctx.strokeRect(x*SQ, y*SQ, SQ, SQ);
        }
    }

    function drawBoard(){
        for(let r = 0; r < ROW; r++){
            for(let c = 0; c < COL; c++){
                drawSquare(c, r, board[r][c]);
            }
        }
    }

    class Piece {
        constructor(tetromino, color){
            this.tetromino = tetromino;
            this.color = color;
            this.tetrominoN = 0; 
            this.activeTetromino = this.tetromino()[this.tetrominoN];
            this.x = 3;
            this.y = -2;
        }

        fill(color){
            for(let r = 0; r < this.activeTetromino.length; r++){
                for(let c = 0; c < this.activeTetromino.length; c++){
                    if(this.activeTetromino[r][c]){
                        // 这里很重要：只有当 y>=0 时才绘制，但在碰撞检测时要检测负值
                        if(this.y + r >= 0) {
                            drawSquare(this.x + c, this.y + r, color);
                        }
                    }
                }
            }
        }

        draw(){ this.fill(this.color); }
        unDraw(){ this.fill(VACANT); }

        moveDown(){
            if(!this.collision(0, 1, this.activeTetromino)){
                this.unDraw();
                this.y++;
                this.draw();
            } else {
                this.lock();
                if(!gameOver) p = randomPiece();
            }
        }

        moveRight(){
            if(!this.collision(1, 0, this.activeTetromino)){
                this.unDraw();
                this.x++;
                this.draw();
            }
        }

        moveLeft(){
            if(!this.collision(-1, 0, this.activeTetromino)){
                this.unDraw();
                this.x--;
                this.draw();
            }
        }

        rotate(){
            let nextPattern = this.tetromino()[(this.tetrominoN + 1) % this.tetromino().length];
            let kick = 0;
            if(this.collision(0, 0, nextPattern)){
                if(this.x > COL/2) kick = -1; 
                else kick = 1;
                
                if(this.collision(kick, 0, nextPattern)){
                    // 如果踢一格还是撞，就不转了
                    return;
                }
            }
            this.unDraw();
            this.x += kick;
            this.tetrominoN = (this.tetrominoN + 1) % this.tetromino().length;
            this.activeTetromino = nextPattern;
            this.draw();
        }

        hardDrop(){
            while(!this.collision(0, 1, this.activeTetromino)){
                this.unDraw();
                this.y++;
                this.draw(); // 这里为了视觉连贯可以不重绘，直接算最后位置，但为了简单逻辑保留
            }
            this.draw(); // 确保最后位置被画出来
            this.lock();
            if(!gameOver) p = randomPiece();
        }

        lock(){
            for(let r = 0; r < this.activeTetromino.length; r++){
                for(let c = 0; c < this.activeTetromino.length; c++){
                    if(!this.activeTetromino[r][c]) continue;
                    // 游戏结束判定
                    if(this.y + r < 0){
                        gameOver = true;
                        modal.style.display = "flex";
                        finalScoreEl.innerText = score;
                        return;
                    }
                    board[this.y+r][this.x+c] = this.color;
                }
            }
            
            // 消除逻辑
            let rowsCleared = 0;
            for(let r = 0; r < ROW; r++){
                let isFull = true;
                for(let c = 0; c < COL; c++){
                    if(board[r][c] === VACANT){
                        isFull = false;
                        break;
                    }
                }
                if(isFull){
                    rowsCleared++;
                    // 消除动画：简单的闪烁
                    for(let c=0; c<COL; c++) drawSquare(c, r, "#FFF");
                    
                    // 下移
                    for(let y = r; y > 0; y--){
                        for(let c = 0; c < COL; c++){
                            board[y][c] = board[y-1][c];
                        }
                    }
                    for(let c = 0; c < COL; c++) board[0][c] = VACANT;
                }
            }

            if(rowsCleared > 0){
                score += rowsCleared * 100 * level; // 简单计分
                scoreEl.innerText = score;
                level = Math.floor(score / 500) + 1;
                levelEl.innerText = level;
            }
            drawBoard();
        }

        collision(x, y, piece){
            for(let r = 0; r < piece.length; r++){
                for(let c = 0; c < piece.length; c++){
                    if(!piece[r][c]) continue;
                    let newX = this.x + c + x;
                    let newY = this.y + r + y;
                    if(newX < 0 || newX >= COL || newY >= ROW) return true;
                    if(newY < 0) continue;
                    if(board[newY][newX] !== VACANT) return true;
                }
            }
            return false;
        }
    }

    function randomPiece(){
        let r = Math.floor(Math.random() * PIECES.length);
        return new Piece(PIECES[r][0], PIECES[r][1]);
    }

    function drop(){
        if(gameOver) return;
        let now = Date.now();
        let delta = now - dropStart;
        let speed = Math.max(100, 1000 - (level-1)*100);

        if(delta > speed){
            p.moveDown();
            dropStart = Date.now();
        }
        requestAnimationFrame(drop);
    }

    // 全局渲染循环：每帧清空画布并重绘棋盘和当前方块，避免部分擦除产生残影
    let renderAnimId = null;
    function render(){
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBoard();
        if(p && !gameOver) p.draw();
        renderAnimId = requestAnimationFrame(render);
    }

    // --- 输入绑定 (支持长按效果) ---
    function bindTouch(id, actionStart, actionEnd){
        const btn = document.getElementById(id);
        let interval;
        
        const start = (e) => {
            if(e.cancelable) e.preventDefault();
            if(gameOver) return;
            actionStart();
            // 如果提供了结束动作（通常用于停止移动），则不开启连续触发
            // 简单的连续移动逻辑
            if(!actionEnd && id !== 'btn-rotate' && id !== 'btn-hard-drop') {
                 clearInterval(interval);
                 interval = setInterval(actionStart, 150); // 长按重复触发
            }
        };

        const end = (e) => {
            if(e.cancelable) e.preventDefault();
            clearInterval(interval);
            if(actionEnd) actionEnd();
        };

        btn.addEventListener('touchstart', start, {passive:false});
        btn.addEventListener('touchend', end);
        btn.addEventListener('mousedown', start);
        btn.addEventListener('mouseup', end);
        btn.addEventListener('mouseleave', end);
    }

    bindTouch('btn-left', () => p.moveLeft());
    bindTouch('btn-right', () => p.moveRight());
    bindTouch('btn-down', () => p.moveDown());
    bindTouch('btn-rotate', () => p.rotate());
    bindTouch('btn-hard-drop', () => p.hardDrop());

    // 键盘
    document.addEventListener('keydown', (e) => {
        if(gameOver) return;
        if(e.keyCode == 37) p.moveLeft();
        else if(e.keyCode == 38) p.rotate();
        else if(e.keyCode == 39) p.moveRight();
        else if(e.keyCode == 40) p.moveDown();
        else if(e.keyCode == 32) p.hardDrop();
    });

    function resetGame(){
        modal.style.display = 'none';
        board = [];
        score = 0;
        level = 1;
        scoreEl.innerText = 0;
        levelEl.innerText = 1;
        gameOver = false;
        initBoard();
        // 重新初始化并重启渲染与下落计时
        // 取消之前的渲染循环（如果有）
        if(renderAnimId) cancelAnimationFrame(renderAnimId);
        drawBoard();
        p = randomPiece();
        dropStart = Date.now();
        render();
        drop();
    }

    // 启动
    initBoard();
    p = randomPiece();
    // 启动渲染循环与下落计时
    render();
    drop();

</script>
</body>
</html>